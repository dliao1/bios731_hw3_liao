)
kable(bias_table, digits = 3, caption = "Bias Summary Table")
ggplot(df, aes(x = err_type, y = bias, color = as.factor(beta_true))) +
geom_point(position = position_dodge(width = 0.3), size = 3) +  # Plot points for bias
geom_errorbar(aes(ymin = bias - bias_mcse, ymax = bias + bias_mcse),
position = position_dodge(width = 0.3), width = 0.2) +  # Error bars
labs(title = "Bar plot of Bias",
x = "Error Type",
y = "Bias",
color = "True Beta") +
theme_minimal()
coverage_table <- df %>%
select(n, beta_true, err_type, wald_coverage, boot_p_coverage) %>%
arrange(n, beta_true, err_type) %>%
pivot_wider(
names_from = err_type,
values_from = c(wald_coverage, boot_p_coverage),
names_glue = "{err_type} {.value}",
) %>%
select(n, beta_true, starts_with("Gamma"), starts_with("Normal")) %>%
rename(
"N" = n,
"True Beta" = beta_true,
"Gamma Wald CI" = "Gamma wald_coverage",
"Gamma Bootstrap Percentile CI" = "Gamma boot_p_coverage",
"Normal Wald CI" = "Normal wald_coverage",
"Normal Bootstrap Percentile CI" = "Normal boot_p_coverage",
)
View(df)
# Loads required libraries
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(foreach))
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(here))
suppressPackageStartupMessages(library(tictoc))
# Loads required helper functions
source(here("source", "gen_data.R"))
source(here("source", "fit_lm.R"))
source(here("source", "run_bootstraps.R"))
source(here("source", "get_estimates.R"))
# Increases significant figures in case of really small numbers in estimates
options(pillar.sigfig = 15)
# Creates intermediate directories to save results and data to
if (!dir.exists(here("results"))) {
dir.create(here("results"))
}
if (!dir.exists(here("results", "sim_wald"))) {
dir.create(here("results", "sim_wald"))
}
if (!dir.exists(here("results", "sim_boot_percentile"))) {
dir.create(here("results", "sim_boot_percentile"))
}
if (!dir.exists(here("results", "sim_data"))) {
dir.create(here("results", "sim_data"))
}
wd = getwd()
if(substring(wd, 4, 8) == "Users"){
doLocal = TRUE
suppressPackageStartupMessages(library(doParallel))
cl <- makeCluster(12)
registerDoParallel(cl)
}else{
doLocal = FALSE
}
# Calculates required number of simulations
mc_err <- 0.01
cover <- 0.95
alpha <- 1 - 0.95
n_sim <- round((cover * (1 - cover)) / mc_err^2) #n_sim = 475
# Calculates parameter combinations
n <- c(20)
beta_true <- c(0, 0.5)
err_type <- c(0, 1) # 1 = normal, 0 = gamma
param_grid <- expand.grid(
n = n,
beta_true = beta_true,
err_type = err_type
)
# Sets random seeds
set.seed(3000)
seeds <- floor(runif(n_sim, 1, 10000))
if (doLocal == TRUE) {
params <- NA
# Iterates through 18 parameter combinations
for (i in 1:nrow(param_grid)) {
# Gets current parameters
params <- param_grid[i, ]
# Below foreach loop runs 475 simulations per parameter combo
# sim_results structure: dataframe with 475 rows (simulations), and 4 columns (Wald/Bootstrap percentile/Bootstrap t/Simulation Data),
# each of which is a 1 row dataframe for the specified method (i.e. sim_result$wald[[10]]: 1 row dataframe containing
# beta hat and Wald CI for the 10th simulation run for the current parameter combination )
# At the end of all 475 simulations for the current scenario, I convert every row
# of sim_results back to 1 row dataframes and bind them to dataframes for their corresponding method (Wald/percentile/etc.)
# End result:
# all_wald_estim = 1 dataframe, 475 rows
sim_results <- foreach(
j = 1:n_sim,
.combine = rbind,
.packages = c("tibble", "dplyr", "tidyverse", "broom", "here", "tictoc")
) %dopar% {
# Sets current seed for the simulation run
set.seed(seeds[j])
# Generates simulated data
simdata <- gen_data(n = params$n,
beta_true = params$beta_true,
err_type = params$err_type
)
# Fits model from simulated data
# Note each: each result is one (1) single row
model_fit <- fit_model(simdata)
tic()
# Extracts wald CI
wald_result <- extract_estims(model = model_fit,
beta_true = params$beta_true,
alpha = alpha)
wald_time <- toc(quiet = TRUE)
wald_result <- cbind(wald_result, scenario = i, sim = j, params, time = wald_time$toc - wald_time$tic)
# Computes Bootstrap Percentile estimates
nboot <- 50
tic()
# Generates bootstrap data
boot_data <- get_boot_data(original_data = simdata,
beta_true = params$beta_true,
sample_size = params$n,
nboot = nboot,
alpha = alpha)
# Extracts bootstrap estimates
boot_percent_result <- extract_estim_boot_percent(all_boot_betas = boot_data,
beta_true = params$beta_true,
alpha = alpha)
boot_percent_time <- toc(quiet = TRUE)
boot_percent_result <- cbind(boot_percent_result, scenario = i, sim = j, params, time = boot_percent_time$toc - boot_percent_time$tic)
# Casts 4 rows into 4 lists and makes 4 columns, 1 for each list
tibble(
wald = list(wald_result),
boot_percent = list(boot_percent_result),
sim_data = list(simdata),
)
}
# Turns each row in each column into a dataframe and binds all rows together for all 475  results for current
# simulation
all_wald_estim <- bind_rows(lapply(sim_results$wald, as.data.frame))
all_boot_percent_estim <- bind_rows(lapply(sim_results$boot_percent, as.data.frame))
all_sim_data <- bind_rows(lapply(sim_results$sim_data, as.data.frame))
# Saves **only** the current parameter combination’s results
save(all_wald_estim, file = here("results", "sim_wald", paste0("scenario_", i, ".RDA")))
save(all_boot_percent_estim, file = here("results", "sim_boot_percentile", paste0("scenario_", i, ".RDA")))
save(all_sim_data, file = here("results", "sim_data", paste0("scenario_", i, ".RDA")))
# Prints progress
cat(sprintf("Saved scenario %d (n = %d, beta_true = %.2f, err_type = %d)\n",
i, params$n, params$beta_true, params$err_type))
}
stopCluster(cl)
} else { # on cluster
i <- as.numeric(commandArgs(trailingOnly=TRUE))
params = param_grid[i,]
sim_results <- foreach(
j = 1:n_sim,
.combine = rbind,
.packages = c("tibble", "dplyr", "tidyverse", "broom", "here", "tictoc")
) %do% {
# Sets current seed for the simulation run
set.seed(seeds[j])
# Generates simulated data
simdata <- gen_data(n = params$n,
beta_true = params$beta_true,
err_type = params$err_type
)
# Fits model from simulated data
# Note each: each result is one (1) single row
model_fit <- fit_model(simdata)
tic()
# Extracts wald CI
wald_result <- extract_estims(model = model_fit,
beta_true = params$beta_true,
alpha = alpha)
wald_time <- toc(quiet = TRUE)
wald_result <- cbind(wald_result, scenario = i, sim = j, params, time = wald_time$toc - wald_time$tic)
# Computes Bootstrap Percentile estimates
nboot <- 50
tic()
# Generates bootstrap data
boot_data <- get_boot_data(original_data = simdata,
beta_true = params$beta_true,
sample_size = params$n,
nboot = nboot,
alpha = alpha)
# Extracts bootstrap estimates
boot_percent_result <- extract_estim_boot_percent(all_boot_betas = boot_data,
beta_true = params$beta_true,
alpha = alpha)
boot_percent_time <- toc(quiet = TRUE)
boot_percent_result <- cbind(boot_percent_result, scenario = i, sim = j, params, time = boot_percent_time$toc - boot_percent_time$tic)
# Casts 4 rows into 4 lists and makes 4 columns, 1 for each list
tibble(
wald = list(wald_result),
boot_percent = list(boot_percent_result),
sim_data = list(simdata),
)
}
# Turns each row in each column into a dataframe and binds all rows together for all 475  results for current
# simulation
all_wald_estim <- bind_rows(lapply(sim_results$wald, as.data.frame))
all_boot_percent_estim <- bind_rows(lapply(sim_results$boot_percent, as.data.frame))
all_sim_data <- bind_rows(lapply(sim_results$sim_data, as.data.frame))
# Saves **only** the current parameter combination’s results
save(all_wald_estim, file = here("results", "sim_wald", paste0("scenario_", i, ".RDA")))
save(all_boot_percent_estim, file = here("results", "sim_boot_percentile", paste0("scenario_", i, ".RDA")))
save(all_sim_data, file = here("results", "sim_data", paste0("scenario_", i, ".RDA")))
# Prints progress
cat(sprintf("Saved scenario %d (n = %d, beta_true = %.2f, err_type = %d)\n",
i, params$n, params$beta_true, params$err_type))
}
library(tidyverse)
library(here)
library(tidyr)
library(knitr)
library(dplyr)
library(ggplot2)
library(dplyr)
library(cowplot)
library(kableExtra)
library(patchwork)
knitr::opts_chunk$set(tidy = FALSE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(echo = FALSE)
tibble(
Problem = c("Problem 0", "Problem 1"),
Points = c(20, 80)
) %>%
knitr::kable()
num_scenarios <- 1 * 2 * 2
mc_err <- 0.01
cover <- 0.95
alpha <- 1 - 0.95
n_sim <- (cover * (1 - cover))/mc_err^2
n_sim
all_wald_results <- vector("list", num_scenarios)
all_boot_p_results <- vector("list", num_scenarios)
# Loop through each scenario file
for (i in 1:num_scenarios) {
file_path <- here("results", "sim_wald", paste0("scenario_", i, ".RDA"))
load(file_path)
all_wald_results[[i]] <- all_wald_estim %>% mutate(err_type = ifelse(err_type == 1), "Normal", "Gamma")
file_path <- here("results", "sim_boot_percentile", paste0("scenario_", i, ".RDA"))
load(file_path)
all_boot_p_results[[i]] <- all_boot_percent_estim %>% mutate(err_type = ifelse(err_type == 1), "Normal", "Gamma")
}
View(all_wald_estim)
library(tidyverse)
library(here)
library(tidyr)
library(knitr)
library(dplyr)
library(ggplot2)
library(dplyr)
library(cowplot)
library(kableExtra)
library(patchwork)
knitr::opts_chunk$set(tidy = FALSE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(echo = FALSE)
tibble(
Problem = c("Problem 0", "Problem 1"),
Points = c(20, 80)
) %>%
knitr::kable()
num_scenarios <- 1 * 2 * 2
mc_err <- 0.01
cover <- 0.95
alpha <- 1 - 0.95
n_sim <- (cover * (1 - cover))/mc_err^2
n_sim
all_wald_results <- vector("list", num_scenarios)
all_boot_p_results <- vector("list", num_scenarios)
# Loop through each scenario file
for (i in 1:num_scenarios) {
file_path <- here("results", "sim_wald", paste0("scenario_", i, ".RDA"))
load(file_path)
all_wald_results[[i]] <- all_wald_estim %>% mutate(err_type = (ifelse(err_type == 1), "Normal", "Gamma"))
library(tidyverse)
library(here)
library(tidyr)
library(knitr)
library(dplyr)
library(ggplot2)
library(dplyr)
library(cowplot)
library(kableExtra)
library(patchwork)
knitr::opts_chunk$set(tidy = FALSE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(echo = FALSE)
tibble(
Problem = c("Problem 0", "Problem 1"),
Points = c(20, 80)
) %>%
knitr::kable()
num_scenarios <- 1 * 2 * 2
mc_err <- 0.01
cover <- 0.95
alpha <- 1 - 0.95
n_sim <- (cover * (1 - cover))/mc_err^2
n_sim
all_wald_results <- vector("list", num_scenarios)
all_boot_p_results <- vector("list", num_scenarios)
# Loop through each scenario file
for (i in 1:num_scenarios) {
file_path <- here("results", "sim_wald", paste0("scenario_", i, ".RDA"))
load(file_path)
all_wald_results[[i]] <- all_wald_estim %>%
mutate(err_type = ifelse(err_type == 0, "Gamma", "Normal"))
file_path <- here("results", "sim_boot_percentile", paste0("scenario_", i, ".RDA"))
load(file_path)
all_boot_p_results[[i]] <- all_boot_percent_estim %>%
mutate(err_type = ifelse(err_type == 0, "Gamma", "Normal"))
}
# Each list is of length 4 since 4 parameter combinations
all_biases <- rep(NA, num_scenarios)
var_hat <- rep(NA, num_scenarios)
wald_coverage <- rep(NA, num_scenarios)
boot_p_coverage <- rep(NA, num_scenarios)
wald_time <- rep(NA, num_scenarios)
boot_p_time <- rep(NA, num_scenarios)
all_n <- rep(NA, num_scenarios)
all_beta_true <- rep(NA, num_scenarios)
all_err_type <- rep(NA, num_scenarios)
scenario_num <- rep(NA, num_scenarios)
mean_wald_se_beta <- rep(NA, num_scenarios)
mean_boot_p_se_beta <- rep(NA, num_scenarios)
se_hat <- rep(NA, num_scenarios)
se_hat_se <- rep(NA, num_scenarios)
wald_type1 <- rep(NA, num_scenarios)
boot_p_type1 <- rep(NA, num_scenarios)
wald_power <- rep(NA, num_scenarios)
boot_p_power <- rep(NA, num_scenarios)
bias_mcse <- rep(NA, num_scenarios)
coverage_mcse <- rep(NA, num_scenarios)
wald_power_mcse <- rep(NA, num_scenarios)
wald_type1_mcse <- rep(NA, num_scenarios)
n_sim <- 475
for (i in 1:num_scenarios) {
all_biases[i] <- (1/n_sim) * sum(all_wald_results[[i]]$beta_hat - all_wald_results[[i]]$beta_true)
var_hat[i] <- sd(all_wald_results[[i]]$beta_hat)
se_hat[i] <- mean(all_wald_results[[i]]$se_beta)
se_hat_se[i] <- sd(all_wald_results[[i]]$se_beta)
wald_coverage[i] <- mean(all_wald_results[[i]]$coverage == 1)
boot_p_coverage[i] <- mean(all_boot_p_results[[i]]$coverage == 1)
wald_time[i] <- mean(all_wald_results[[i]]$time)
boot_p_time[i] <- mean(all_boot_p_results[[i]]$time)
all_n[i] <- unique(all_wald_results[[i]]$n)[[1]]
all_beta_true[i] <- unique(all_wald_results[[i]]$beta_true)
all_err_type[i] <- unique(all_wald_results[[i]]$err_type)
mean_wald_se_beta[i] <- mean(all_wald_results[[i]]$se_beta)
mean_boot_p_se_beta[i] <- mean(all_boot_p_results[[i]]$se_beta)
# Power = p(detecting an effect)
# = p(rejecting null when null false)
# = 1 - p(NOT rejecting null when null false)
# = 1 - p(0 in CI when beta_true = 0.5)
#  = p(0 not in CI when beta_true = 0.5)
# type I error
# p(rejecting null when null is true)
# = p(0 not in CI when beta_true = 0)
if (unique(all_wald_results[[i]]$beta_true)[[1]] == 0) {
# Compute Type I Error when true beta is 0
wald_type1[i] <- mean(all_wald_results[[i]]$ci_l > 0 | all_wald_results[[i]]$ci_u < 0)
boot_p_type1[i] <- mean(all_boot_p_results[[i]]$ci_l > 0 | all_boot_p_results[[i]]$ci_u < 0)
} else { # beta = 0.5
# Compute Power when true beta is NOT 0
wald_power[i] <- mean(all_wald_results[[i]]$ci_l > 0 | all_wald_results[[i]]$ci_u < 0)
boot_p_power[i] <- mean(all_boot_p_results[[i]]$ci_l > 0 | all_boot_p_results[[i]]$ci_u < 0)
}
scenario_num[i] <- i
bias_mcse[i] <- sqrt(sum((all_wald_results[[i]]$beta_hat - mean(all_wald_results[[i]]$beta_hat))^2) / (n_sim * (n_sim - 1)))
}
# this is 4 rows, 1 for each parameter combo
df <- bind_cols(
scenario_num = scenario_num,
n = all_n,
beta_true = all_beta_true,
error_type = all_err_type,
bias = all_biases,
bias_mcse = bias_mcse,
var = var_hat,
se_hat = se_hat,
se_hat_se = se_hat_se,
wald_coverage = wald_coverage,
wald_coverage_mcse = sqrt(wald_coverage * (1-wald_coverage)/ n_sim) ,
wald_time = wald_time,
wald_power = wald_power,
wald_power_mcse = sqrt(wald_power * (1-wald_power)/n_sim),
wald_type1 = wald_type1,
wald_type1_mcse = sqrt(wald_type1 * (1-wald_type1)/n_sim),
wald_se = mean_wald_se_beta,
boot_p_coverage = boot_p_coverage,
boot_p_coverage_mcse = sqrt(boot_p_coverage * (1-boot_p_coverage)/ n_sim) ,
boot_p_time = boot_p_time,
boot_p_se = mean_boot_p_se_beta,
boot_p_power = boot_p_power,
boot_p_power_mcse= sqrt(boot_p_power * (1-boot_p_power)/n_sim),
boot_p_type1 = boot_p_type1,
boot_p_type1_mcse = sqrt(boot_p_type1 * (1-boot_p_type1)/n_sim),
)
bias_table <- df %>%
select(n, beta_true, error_type, bias) %>%
arrange(n, beta_true) %>%
rename("N" = n, "True Beta" = beta_true) %>%
pivot_wider(
names_from = error_type,
values_from = bias,
)
kable(bias_table, digits = 3, caption = "Bias Summary Table")
ggplot(df, aes(x = error_type, y = bias, color = as.factor(beta_true))) +
geom_point(position = position_dodge(width = 0.3), size = 3) +  # Plot points for bias
geom_errorbar(aes(ymin = bias - bias_mcse, ymax = bias + bias_mcse),
position = position_dodge(width = 0.3), width = 0.2) +  # Error bars
labs(title = "Bar plot of Bias",
x = "Error Type",
y = "Bias",
color = "True Beta") +
theme_minimal()
coverage_table <- df %>%
select(n, beta_true, error_type, wald_coverage, boot_p_coverage) %>%
arrange(n, beta_true, error_type) %>%
pivot_wider(
names_from = error_type,
values_from = c(wald_coverage, boot_p_coverage),
names_glue = "{error_type} {.value}",
) %>%
select(n, beta_true, starts_with("Gamma"), starts_with("Normal")) %>%
rename(
"N" = n,
"True Beta" = beta_true,
"Gamma Wald CI" = "Gamma wald_coverage",
"Gamma Bootstrap Percentile CI" = "Gamma boot_p_coverage",
"Normal Wald CI" = "Normal wald_coverage",
"Normal Bootstrap Percentile CI" = "Normal boot_p_coverage",
)
kable(coverage_table, digits = 3, caption = "Coverage Summary Table") %>%
add_header_above(c(" " = 2, "Gamma" = 2, "Normal" = 2)) %>%
column_spec(1, width = "1cm") %>%
column_spec(2, width = "1cm") %>%
column_spec(3:6, width = "2cm")
y_min <- min(df$wald_coverage - df$wald_coverage_mcse, df$boot_p_coverage - df$boot_p_coverage_mcse)
y_max <- max(df$wald_coverage + df$wald_coverage_mcse, df$boot_p_coverage + df$boot_p_coverage_mcse)
wald_plot <- ggplot(df, aes(x = error_type, y = wald_coverage, color = as.factor(beta_true))) +
geom_point(position = position_dodge(width = 0.3), size = 3) +
geom_errorbar(aes(ymin = wald_coverage - wald_coverage_mcse,
ymax = wald_coverage + wald_coverage_mcse),
position = position_dodge(width = 0.3), width = 0.2) +
labs(title = "Wald Coverage", x = "Error Type", y = "Coverage (%)", color = "True Beta") +
coord_cartesian(ylim = c(y_min, y_max)) +
theme_minimal()
boot_plot <- ggplot(df, aes(x = error_type, y = boot_p_coverage, color = as.factor(beta_true))) +
geom_point(position = position_dodge(width = 0.3), size = 3) +
geom_errorbar(aes(ymin = boot_p_coverage - boot_p_coverage_mcse,
ymax = boot_p_coverage + boot_p_coverage_mcse),
position = position_dodge(width = 0.3), width = 0.2) +
labs(title = "Bootstrap Percentile Coverage", x = "Error Type", y = "Coverage (%)", color = "True Beta") +
coord_cartesian(ylim = c(y_min, y_max)) +
theme_minimal()
(wald_plot + boot_plot) + plot_layout(ncol = 2, heights = c(5))
df
ggplot(df, aes(x = error_type, y = wald_power, color = as.factor(beta_true))) +
geom_point(position = position_dodge(width = 0.3), size = 3) +  # Plot points for power
geom_errorbar(aes(ymin = wald_power - wald_power_mcse,
ymax = wald_power + wald_power_mcse),
position = position_dodge(width = 0.3), width = 0.2) +  # Error bars
labs(title = "Wald Power with Monte Carlo SE Error Bars",
x = "Error Type",
y = "Power",
color = "True Beta") +
theme_minimal()
y_min <- min(c(df$wald_power - df$wald_power_mcse, df$boot_p_power - df$boot_p_power_mcse), na.rm = TRUE)
y_max <- max(c(df$wald_power + df$wald_power_mcse, df$boot_p_power + df$boot_p_power_mcse), na.rm = TRUE)
wald_plot <- ggplot(df, aes(x = error_type, y = wald_power, color = as.factor(beta_true))) +
geom_point(position = position_dodge(width = 0.3), size = 3) +
geom_errorbar(aes(ymin = wald_power - wald_power_mcse,
ymax = wald_power + wald_power_mcse),
position = position_dodge(width = 0.3), width = 0.2) +
labs(title = "Wald Power", x = "Error Type", y = "Power", color = "True Beta") +
coord_cartesian(ylim = c(y_min, y_max)) +
theme_minimal()
boot_plot <- ggplot(df, aes(x = error_type, y = boot_p_power, color = as.factor(beta_true))) +
geom_point(position = position_dodge(width = 0.3), size = 3) +
geom_errorbar(aes(ymin = boot_p_power - boot_p_power_mcse,
ymax = boot_p_power + boot_p_power_mcse),
position = position_dodge(width = 0.3), width = 0.2) +
labs(title = "Bootstrap Percentile Power", x = "Error Type", y = "Power", color = "True Beta") +
coord_cartesian(ylim = c(y_min, y_max)) +
theme_minimal()
(wald_plot + boot_plot) + plot_layout(ncol = 2, heights = c(5))
y_min <- min(c(df$wald_type1 - df$wald_type1_mcse, df$boot_p_type1 - df$boot_p_type1_mcse), na.rm = TRUE)
y_max <- max(c(df$wald_type1 + df$wald_type1_mcse, df$boot_p_type1 + df$boot_p_type1_mcse), na.rm = TRUE)
wald_plot <- ggplot(df, aes(x = error_type, y = wald_type1, color = as.factor(beta_true))) +
geom_point(position = position_dodge(width = 0.3), size = 3) +
geom_errorbar(aes(ymin = wald_type1 - wald_type1_mcse,
ymax = wald_type1 + wald_type1_mcse),
position = position_dodge(width = 0.3), width = 0.2) +
labs(title = "Wald Type I Error", x = "Error Type", y = "Type I Error", color = "True Beta") +
coord_cartesian(ylim = c(y_min, y_max)) +
theme_minimal()
boot_plot <- ggplot(df, aes(x = error_type, y = boot_p_type1, color = as.factor(beta_true))) +
geom_point(position = position_dodge(width = 0.3), size = 3) +
geom_errorbar(aes(ymin = boot_p_type1 - boot_p_type1_mcse,
ymax = boot_p_type1 + boot_p_type1_mcse),
position = position_dodge(width = 0.3), width = 0.2) +
labs(title = "Bootstrap Percentile Type I Error", x = "Error Type", y = "Type I Error", color = "True Beta") +
coord_cartesian(ylim = c(y_min, y_max)) +
theme_minimal()
(wald_plot + boot_plot) + plot_layout(ncol = 2, heights = c(5))
View(all_wald_estim)
